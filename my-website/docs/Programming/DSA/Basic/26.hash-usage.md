# Hash Maps và Hash Sets: Cấu Trúc Dữ Liệu Quan Trọng Nhất Trong Lập Trình

Hash maps (bảng băm) và hash sets (tập hợp băm) là những cấu trúc dữ liệu được sử dụng nhiều nhất trong lập trình, từ phỏng vấn kỹ thuật đến các dự án thực tế. Trong bài viết này, chúng ta sẽ tập trung vào cách **sử dụng** hash maps thay vì cách **triển khai** chúng, vì việc biết cách sử dụng hiệu quả quan trọng hơn nhiều.

---

## 1. Tổng Quan về Maps và Sets

### 1.1. Set (Tập hợp)
- **Set** là một tập hợp các giá trị duy nhất: `{1, 2, 3}`.
- Không cho phép các phần tử trùng lặp.

### 1.2. Map (Ánh xạ)
- **Map** phức tạp hơn, là tập hợp các cặp key-value (khóa-giá trị).
- Ví dụ: Danh bạ điện thoại với tên người là key, số điện thoại là value.
- Key được sử dụng để truy cập và sắp xếp dữ liệu.

---

## 2. So Sánh Tree Maps vs Hash Maps

| Thao tác       | Tree Map | Hash Map |
|----------------|----------|----------|
| **Insert**     | O(log n) | O(1)*    |
| **Remove**     | O(log n) | O(1)*    |
| **Search**     | O(log n) | O(1)*    |
| **Duyệt có thứ tự** | O(n) | O(n log n) |

*\*Lưu ý: O(1) ở đây là **average case** (trường hợp trung bình), không phải worst case.*

### 2.1. Ưu điểm của Hash Maps
- **Hiệu suất vượt trội**: Các thao tác cơ bản đều có độ phức tạp O(1).
- **Phù hợp cho hầu hết ứng dụng**: Khi không cần duy trì thứ tự sắp xếp.

### 2.2. Nhược điểm của Hash Maps
- **Không duy trì thứ tự**: Nếu cần duyệt theo thứ tự sắp xếp, phải sắp xếp lại với độ phức tạp O(n log n).
- **Worst case có thể là O(n)**: Trong trường hợp xấu nhất (collision nhiều), các thao tác có thể chậm hơn.

---

## 3. Ví Dụ Thực Tế: Đếm Số Lần Xuất Hiện Của Tên

### 3.1. Bài Toán
Cho một danh sách tên: `["Alice", "Brad", "Colin", "Brad", "Dylan", "Kim"]`
Hãy đếm số lần mỗi tên xuất hiện.

### 3.2. Phân Tích Thuật Toán

**Bước 1:** Khởi tạo hash map rỗng
```
count_map = {}
```

**Bước 2:** Duyệt qua từng tên trong danh sách
- "Alice": Không có trong map → Thêm Alice: 1
- "Brad": Không có trong map → Thêm Brad: 1  
- "Colin": Không có trong map → Thêm Colin: 1
- "Brad": Đã có trong map → Tăng count lên: Brad: 2
- "Dylan": Không có trong map → Thêm Dylan: 1
- "Kim": Không có trong map → Thêm Kim: 1

**Kết quả cuối cùng:**
```
{
    "Alice": 1,
    "Brad": 2, 
    "Colin": 1,
    "Dylan": 1,
    "Kim": 1
}
```

### 3.3. Phân Tích Độ Phức Tạp

- **Thời gian**: O(n) - với n là số phần tử trong danh sách
  - Mỗi thao tác search và insert đều là O(1)
  - Có n phần tử → tổng cộng O(n)

- **Không gian**: O(n) - trong trường hợp xấu nhất tất cả tên đều khác nhau

**So sánh với Tree Map:**
- Tree Map sẽ có độ phức tạp O(n log n) vì mỗi thao tác insert/search là O(log n)
- Hash Map hiệu quả hơn đáng kể!

---

## 4. Code Implementation trong Python

```python
def count_names(names):
    """
    Đếm số lần xuất hiện của mỗi tên trong danh sách
    
    Args:
        names: List các tên cần đếm
    
    Returns:
        Dictionary với key là tên, value là số lần xuất hiện
    """
    count_map = {}  # Khởi tạo hash map rỗng
    
    for name in names:
        if name not in count_map:  # O(1) - kiểm tra key có tồn tại
            count_map[name] = 1    # O(1) - thêm key mới
        else:
            count_map[name] += 1   # O(1) - cập nhật giá trị
    
    return count_map

# Ví dụ sử dụng
names = ["Alice", "Brad", "Colin", "Brad", "Dylan", "Kim"]
result = count_names(names)
print(result)
# Output: {'Alice': 1, 'Brad': 2, 'Colin': 1, 'Dylan': 1, 'Kim': 1}
```

### 4.1. Cách Viết Ngắn Gọn Hơn

```python
from collections import defaultdict

def count_names_v2(names):
    count_map = defaultdict(int)  # Tự động khởi tạo giá trị 0
    
    for name in names:
        count_map[name] += 1
    
    return dict(count_map)

# Hoặc sử dụng Counter
from collections import Counter

def count_names_v3(names):
    return dict(Counter(names))
```

---

## 5. Đặc Tính Quan Trọng của Hash Maps

### 5.1. Không Cho Phép Duplicate Keys
- Mỗi key chỉ xuất hiện một lần trong hash map
- Nếu thêm key đã tồn tại, giá trị cũ sẽ bị ghi đè
- Tương tự như Tree Maps và Sets

### 5.2. Key-Value Mapping
- Key được sử dụng để truy cập value
- Key phải là kiểu dữ liệu immutable (string, number, tuple)
- Value có thể là bất kỳ kiểu dữ liệu nào

---

## 6. Các Ứng Dụng Thực Tế Khác

### 6.1. Cache/Memoization
```python
# Cách CHẬM (không có cache):

def fibonacci_slow(n):
    if n <= 1:
        return n
    return fibonacci_slow(n-1) + fibonacci_slow(n-2)

# Test
print(fibonacci_slow(5))  # Kết quả: 5
print(fibonacci_slow(10)) # Kết quả: 55
# fibonacci_slow(40) # Sẽ rất chậm!
# Vấn đề: Tính toán lặp lại nhiều lần!

# Ví dụ tính F(5):

F(5) = F(4) + F(3)
     = [F(3) + F(2)] + [F(2) + F(1)]
     = [F(2) + F(1) + F(2)] + [F(2) + F(1)]
     = [F(1) + F(0) + F(1) + F(2)] + [F(1) + F(0) + F(1)]
→ F(2) được tính 3 lần, F(1) được tính 5 lần! Lãng phí!
#### dùng cache
def fibonacci_with_cache():
    cache = {}  # Từ điển lưu trữ kết quả đã tính
    
    def fib(n):
        # Bước 1: Kiểm tra cache trước
        if n in cache:
            print(f"Lấy từ cache: F({n}) = {cache[n]}")
            return cache[n]
        
        # Bước 2: Tính toán nếu chưa có trong cache
        if n <= 1:
            result = n
        else:
            print(f"Đang tính F({n})...")
            result = fib(n-1) + fib(n-2)
        
        # Bước 3: Lưu kết quả vào cache
        cache[n] = result
        print(f"Lưu vào cache: F({n}) = {result}")
        return result
    
    return fib  # Trả về function fib

### demo 
# Tạo function với cache
fib = fibonacci_with_cache()

print("=== Tính F(5) lần đầu ===")
result = fib(5)
print(f"Kết quả: {result}")

print("\n=== Tính F(5) lần thứ 2 ===")
result = fib(5)  # Lần này sẽ lấy từ cache
print(f"Kết quả: {result}")

print("\n=== Tính F(7) ===")
result = fib(7)  # Sẽ tái sử dụng các giá trị đã cache
print(f"Kết quả: {result}")

### output 
=== Tính F(5) lần đầu ===
Đang tính F(5)...
Đang tính F(4)...
Đang tính F(3)...
Đang tính F(2)...
Lưu vào cache: F(0) = 0
Lưu vào cache: F(1) = 1
Lưu vào cache: F(2) = 1
Lấy từ cache: F(1) = 1
Lưu vào cache: F(3) = 2
Lấy từ cache: F(2) = 1
Lưu vào cache: F(4) = 3
Lấy từ cache: F(3) = 2
Lưu vào cache: F(5) = 5
Kết quả: 5

=== Tính F(5) lần thứ 2 ===
Lấy từ cache: F(5) = 5
Kết quả: 5

=== Tính F(7) ===
Đang tính F(7)...
Đang tính F(6)...
Lấy từ cache: F(5) = 5
Lấy từ cache: F(4) = 3
Lưu vào cache: F(6) = 8
Lấy từ cache: F(5) = 5
Lưu vào cache: F(7) = 13
Kết quả: 13
```

### 6.2. Database Indexing
```python
users = [
    {'id': 1, 'name': 'Alice', 'email': 'alice@email.com'},
    {'id': 2, 'name': 'Bob', 'email': 'bob@email.com'},
    {'id': 3, 'name': 'Charlie', 'email': 'charlie@email.com'},
    {'id': 4, 'name': 'Diana', 'email': 'diana@email.com'},
    # ... có thể có hàng nghìn users
]

# Cách tra cứu CHẬM - phải duyệt qua từng user
def find_user_slow(users, user_id):
    for user in users:  # Duyệt từ đầu đến cuối list
        if user['id'] == user_id:
            return user
    return None

# Ví dụ: tìm user có id = 3
result = find_user_slow(users, 3)
print(result)  # {'id': 3, 'name': 'Charlie', 'email': 'charlie@email.com'}
# Vấn đề: Nếu có 1000 users và user bạn cần tìm ở cuối danh sách, phải duyệt qua 1000 users → O(n)


def create_user_index(users):
    """Tạo 'từ điển tra cứu' user theo ID"""
    user_index = {}
    
    for user in users:
        # Dùng ID làm key, toàn bộ thông tin user làm value
        user_index[user['id']] = user
    
    return user_index



# Tạo index một lần
users_index = create_user_index(users)
print("Index được tạo:")
print(users_index)

# Kết quả index sẽ như thế này:
{
    1: {'id': 1, 'name': 'Alice', 'email': 'alice@email.com'},
    2: {'id': 2, 'name': 'Bob', 'email': 'bob@email.com'}, 
    3: {'id': 3, 'name': 'Charlie', 'email': 'charlie@email.com'},
    4: {'id': 4, 'name': 'Diana', 'email': 'diana@email.com'}
}
def find_user_by_id(user_index, user_id):
    """Tra cứu NHANH bằng hash map"""
    return user_index.get(user_id)  # Truy cập trực tiếp bằng key

# Sử dụng
user = find_user_by_id(users_index, 3)
print(user)  # {'id': 3, 'name': 'Charlie', 'email': 'charlie@email.com'}
```

### 6.3. Two Sum Problem
```python
### de bai 
nums = [2, 7, 11, 15]
target = 9
# Kết quả: [0, 1] vì nums[0] + nums[1] = 2 + 7 = 9
### code cùi  
def two_sum_slow(nums, target):
    """Cách chậm: Thử tất cả các cặp"""
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            if nums[i] + nums[j] == target:
                return [i, j]
    return []

# Test
nums = [2, 7, 11, 15]
target = 9
result = two_sum_slow(nums, target)
print(f"Kết quả: {result}")  # [0, 1]

Vấn đề: Với n phần tử, phải thử n*(n-1)/2 cặp → O(n²) - rất chậm!

Thay vì thử tất cả các cặp, ta sử dụng "complement" (số bù):

Với mỗi số num, ta tìm complement = target - num
Nếu complement đã gặp trước đó → tìm thấy cặp!
Sử dụng hash map để lưu trữ: {giá_trị: chỉ_số}

def two_sum_with_debug(nums, target):
    print(f"Tìm hai số có tổng = {target} trong {nums}")
    num_map = {}
    
    for i, num in enumerate(nums):
        complement = target - num
        print(f"\nBước {i+1}: num = {num}, complement = {complement}")
        print(f"num_map hiện tại: {num_map}")
        
        if complement in num_map:
            result = [num_map[complement], i]
            print(f"✅ Tìm thấy! nums[{num_map[complement]}] + nums[{i}] = {nums[num_map[complement]]} + {num} = {target}")
            return result
        
        num_map[num] = i
        print(f"Lưu {num} → index {i} vào map")
    
    print("❌ Không tìm thấy cặp nào")
    return []

# Test
nums = [2, 7, 11, 15]
target = 9
result = two_sum_with_debug(nums, target)
print(f"\nKết quả cuối: {result}")

Tìm hai số có tổng = 9 trong [2, 7, 11, 15]

Bước 1: num = 2, complement = 7
num_map hiện tại: {}
Lưu 2 → index 0 vào map

Bước 2: num = 7, complement = 2
num_map hiện tại: {2: 0}
✅ Tìm thấy! nums[0] + nums[1] = 2 + 7 = 9

Kết quả cuối: [0, 1]
```

---

## 7. Khi Nào Nên Sử Dụng Hash Maps?

### ✅ Sử dụng Hash Maps khi:
- Cần truy cập, thêm, xóa dữ liệu nhanh chóng (O(1))
- Không cần duy trì thứ tự sắp xếp
- Cần đếm, nhóm, hoặc tra cứu dữ liệu
- Xử lý large datasets với yêu cầu hiệu suất cao

### ❌ Không nên sử dụng Hash Maps khi:
- Cần duy trì thứ tự sắp xếp (dùng Tree Map)
- Cần duyệt dữ liệu theo thứ tự thường xuyên
- Memory usage là vấn đề quan trọng (hash maps có overhead)

---

## 8. Tổng Kết

Hash Maps là công cụ mạnh mẽ và cần thiết trong toolkit của mọi developer:

- **Hiệu suất xuất sắc**: O(1) cho các thao tác cơ bản
- **Đa dụng**: Phù hợp với nhiều loại bài toán
- **Dễ sử dụng**: Syntax đơn giản trong hầu hết ngôn ngữ lập trình
- **Ứng dụng rộng rãi**: Từ caching đến database indexing

Việc thành thạo hash maps sẽ giúp bạn giải quyết nhiều bài toán một cách hiệu quả và elegant. Hãy thực hành thường xuyên với các bài tập khác nhau để làm chủ cấu trúc dữ liệu quan trọng này!

